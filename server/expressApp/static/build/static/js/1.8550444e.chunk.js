(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{35:function(e,t,n){"use strict";n.d(t,"a",function(){return c});var a=n(32),o=n.n(a),r=n(33),i=n(2),s=n(3),c=function(){function e(){Object(i.a)(this,e)}return Object(s.a)(e,[{key:"load",value:function(){var t=Object(r.a)(o.a.mark(function t(n,a,r){var i,s,c,u,l,d;return o.a.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return i=Object.assign(a||{},{cache:"no-cache",credentials:"same-origin",headers:{"content-type":"application/json"},method:"GET",mode:"cors",redirect:"follow",referrer:"no-referrer"}),t.next=3,fetch(n,i);case 3:s=t.sent,t.t0=r,t.next=t.t0===e.TEXT?7:t.t0===e.IMAGE?11:t.t0===e.ARRAY_BUFFER?20:25;break;case 7:return t.next=9,s.text();case 9:return c=t.sent,t.abrupt("break",27);case 11:return t.next=13,s.blob();case 13:return u=t.sent,(l=new Image).src=URL.createObjectURL(u),t.next=18,new Promise(function(e,t){l.onload=function(){e(l)},l.onerror=function(e){t(e.path)}});case 18:return c=t.sent,t.abrupt("break",27);case 20:return t.next=22,s.arrayBuffer();case 22:return d=t.sent,c=d,t.abrupt("break",27);case 25:return c=s.json(),t.abrupt("break",27);case 27:return t.abrupt("return",c);case 28:case"end":return t.stop()}},t)}));return function(e,n,a){return t.apply(this,arguments)}}()}]),e}();c.TEXT="text",c.IMAGE="image",c.ARRAY_BUFFER="array buffer"},36:function(e,t,n){"use strict";var a=n(2),o=n(3),r=function(){function e(){Object(a.a)(this,e)}return Object(o.a)(e,null,[{key:"createWebglContext",value:function(e){return e.getContext("webgl2")}},{key:"loaderShader",value:function(e,t,n){var a=e.createShader(t);return e.shaderSource(a,n),e.compileShader(a),e.getShaderParameter(a,e.COMPILE_STATUS)?a:(alert("An error occurred compiling the shaders: "+e.getShaderInfoLog(a)),e.deleteShader(a),null)}},{key:"createProgram",value:function(t,n,a){var o=this.loaderShader(t,t.VERTEX_SHADER,n),r=this.loaderShader(t,t.FRAGMENT_SHADER,a),i=t.createProgram();return t.attachShader(i,o),t.attachShader(i,r),t.linkProgram(i),t.getProgramParameter(i,t.LINK_STATUS)?(e.deleteShader(t,o),e.deleteShader(t,r),i):(t.deleteProgram(i),console.error("Unable to initialize the shader program: "+t.getProgramInfoLog(i)),null)}},{key:"createUniformsInfo",value:function(e,t){for(var n=e.getProgramParameter(t,e.ACTIVE_UNIFORMS),a=[],o=0;o<n;++o){var r=e.getActiveUniform(t,o);if(!r)break;a.push(r)}return a}},{key:"createAttributesInfo",value:function(e,t){for(var n=e.getProgramParameter(t,e.ACTIVE_ATTRIBUTES),a=[],o=0;o<n;++o){var r=e.getActiveAttrib(t,o);if(!r)break;a.push(r)}return a}},{key:"createProgramInfo",value:function(e,t,n){var a=this.createProgram(e,t,n);return{program:a,uniformsInfo:this.createUniformsInfo(e,a),attributesInfo:this.createAttributesInfo(e,a)}}},{key:"createTexture",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e.CLAMP_TO_EDGE,a=arguments.length>3?arguments[3]:void 0,o=arguments.length>4?arguments[4]:void 0,r=arguments.length>5?arguments[5]:void 0,i=t?e.TEXTURE_CUBE_MAP:e.TEXTURE_2D,s=e.createTexture();return e.bindTexture(i,s),e.texParameteri(i,e.TEXTURE_WRAP_S,n||e.CLAMP_TO_EDGE),e.texParameteri(i,e.TEXTURE_WRAP_T,a||e.CLAMP_TO_EDGE),e.texParameteri(i,e.TEXTURE_MIN_FILTER,o||e.LINEAR),e.texParameteri(i,e.TEXTURE_MAG_FILTER,r||e.LINEAR),t&&e.texParameteri(i,e.TEXTURE_WRAP_R,e.CLAMP_TO_EDGE),s}},{key:"createRenderTarget",value:function(e,t,n){var a={frameBuffer:e.createFramebuffer(),renderBuffer:e.createRenderbuffer()};return this.resizeRenderTarget(e,a,t,n),a}},{key:"createVaoAndBindAttributes",value:function(e,t,n){var a=e.createVertexArray();return this.updateVao(e,a,t,n),a}},{key:"updateVao",value:function(e,t,n,a){e.bindVertexArray(t);var o=[];if(n.forEach(function(t,n){var a=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,a),e.bufferData(e.ARRAY_BUFFER,t.data,e.STATIC_DRAW),e.vertexAttribPointer(n,t.componentNum,e.FLOAT,!1,0,0),e.enableVertexAttribArray(n),o.push(a)}),a){var r=e.createBuffer();e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r),e.bufferData(e.ELEMENT_ARRAY_BUFFER,a.data,e.STATIC_DRAW),o.push(r)}return e.bindBuffer(e.ARRAY_BUFFER,null),e.bindVertexArray(null),o.forEach(function(t){e.deleteBuffer(t)}),t}},{key:"updateTexture2D",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3?arguments[3]:void 0,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:-1,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1,i=arguments.length>6?arguments[6]:void 0,s=arguments.length>7?arguments[7]:void 0,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,u=s||e.UNSIGNED_BYTE,l=a||e.RGBA,d=i||e.RGBA;e.bindTexture(e.TEXTURE_2D,t),o>-1&&r>-1?e.texImage2D(e.TEXTURE_2D,0,l,o,r,0,d,u,n):e.texImage2D(e.TEXTURE_2D,0,l,d,u,n),c>0&&o>-1&&r>-1&&e.texStorage2D(e.TEXTURE_2D,c,l,o,r)}},{key:"updateTextureCube",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],a=arguments.length>3?arguments[3]:void 0,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:-1,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1,i=arguments.length>6?arguments[6]:void 0,s=arguments.length>7?arguments[7]:void 0,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,u=s||e.UNSIGNED_BYTE,l=a||e.RGBA,d=i||e.RGBA;if(e.bindTexture(e.TEXTURE_CUBE_MAP,t),o>-1&&r>-1)for(var f=0;f<6;++f)e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+f,0,l,o,r,0,d,u,n[f]||null);else for(var h=0;h<6;++h)e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+h,0,l,d,u,n[h]);c>0&&o>-1&&r>-1&&e.texStorage2D(e.TEXTURE_CUBE_MAP,c,l,o,r)}},{key:"bindRenderTargetTexture",value:function(e,t,n){var a=t?t.frameBuffer:{frameBuffer:null};e.bindFramebuffer(e.FRAMEBUFFER,a),n&&e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0)}},{key:"bindRenderTargetTextureCube",value:function(e,t,n,a){var o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=t?t.frameBuffer:null;e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_CUBE_MAP_POSITIVE_X+a,n,o)}},{key:"resizeRenderTarget",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:32,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:32;e.bindFramebuffer(e.FRAMEBUFFER,t.frameBuffer),e.bindRenderbuffer(e.RENDERBUFFER,t.renderBuffer),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,n,a),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,t.renderBuffer),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindRenderbuffer(e.RENDERBUFFER,null)}},{key:"deleteShader",value:function(e,t){e.deleteShader(t)}},{key:"deleteVao",value:function(e,t){e.deleteVertexArray(t)}}]),e}(),i=function(){function e(t){Object(a.a)(this,e),this._gl=r.createWebglContext(t),this.curProgram=null}return Object(o.a)(e,[{key:"getContext",value:function(){return this._gl}},{key:"createTexture2D",value:function(e){var t=e.image,n=e.internalFormat,a=e.width,o=e.height,i=e.format,s=e.type,c=e.levels,u=e.ws,l=e.wt,d=e.minF,f=e.maxF,h=this._gl,v=r.createTexture(h,!1,u,l,d,f);return r.updateTexture2D(h,v,t,n,a,o,i,s,c),v}},{key:"createTextureCube",value:function(e){var t=e.imageArr,n=e.internalFormat,a=e.width,o=e.height,i=e.format,s=e.type,c=e.levels,u=e.ws,l=e.wt,d=e.minF,f=e.maxF,h=this._gl,v=r.createTexture(h,!0,u,l,d,f);return r.updateTextureCube(h,v,t,n,a,o,i,s,c),v}},{key:"updateTexture2D",value:function(e){var t=e.textureBuffer,n=e.image,a=e.internalFormat,o=e.width,i=e.height,s=e.format,c=e.type,u=e.levels;r.updateTexture2D(this._gl,t,n,a,o,i,s,c,u)}},{key:"setTexture2D",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=this._gl;n.activeTexture(n.TEXTURE0+t),n.bindTexture(n.TEXTURE_2D,e)}},{key:"setTextureCube",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=this._gl;n.activeTexture(n.TEXTURE0+t),n.bindTexture(n.TEXTURE_CUBE_MAP,e)}},{key:"generateMipmap",value:function(e,t){var n=this._gl;n.bindTexture(e,t),n.generateMipmap(e,t)}},{key:"copyTexture",value:function(e){var t=e.textureBuffer,n=e.target,a=e.texTarget,o=e.level,r=void 0===o?0:o,i=(e.internalFormat,e.x),s=void 0===i?0:i,c=e.y,u=void 0===c?0:c,l=e.width,d=void 0===l?512:l,f=e.height,h=void 0===f?512:f,v=e.border,m=void 0===v?0:v,p=this._gl,g=p.RGBA;p.bindTexture(n,t),p.copyTexImage2D(a,r,g,s,u,d,h,m)}},{key:"createProgramInfo",value:function(e,t){var n=this._gl;return r.createProgramInfo(n,e,t)}},{key:"createRenderTarget",value:function(e,t){return r.createRenderTarget(this._gl,e,t)}},{key:"createVaoFromGeometry",value:function(e){var t=[],n=e.attributes;return Object.keys(n).forEach(function(a,o){1<<o&e.attributesCode&&t.push(n[a])}),r.createVaoAndBindAttributes(this._gl,t,e.indices)}},{key:"updateVaoFromGeometry",value:function(e,t){var n=[],a=t.attributes;return Object.keys(a).forEach(function(e,o){1<<o&t.attributesCode&&n.push(a[e])}),r.updateVao(this._gl,e,n,t.indices)}},{key:"use",value:function(e){this.curProgram=e,this._gl.useProgram(e)}},{key:"setInt",value:function(e,t){var n=this._gl,a=n.getUniformLocation(this.curProgram,e);n.uniform1i(a,t)}},{key:"setFloat",value:function(e,t){var n=this._gl,a=n.getUniformLocation(this.curProgram,e);n.uniform1f(a,t)}},{key:"setVec2",value:function(e,t,n){var a=this._gl,o=a.getUniformLocation(this.curProgram,e);a.uniform2fv(o,[t,n])}},{key:"setVec3",value:function(e,t,n,a){var o=this._gl,r=o.getUniformLocation(this.curProgram,e);o.uniform3fv(r,[t,n,a])}},{key:"setMat4",value:function(e,t){var n=this._gl,a=n.getUniformLocation(this.curProgram,e);n.uniformMatrix4fv(a,!1,t)}},{key:"setRenderTarget",value:function(e,t){r.bindRenderTargetTexture(this._gl,e,t)}},{key:"setCubeRenderTarget",value:function(e,t,n,a){r.bindRenderTargetTextureCube(this._gl,e,t,n,a)}},{key:"resizeRenderTarget",value:function(e,t,n){r.resizeRenderTarget(this._gl,e,t,n)}},{key:"setVao",value:function(e){this._gl.bindVertexArray(e)}},{key:"unBindRenderTarget",value:function(){var e=this._gl;e.bindFramebuffer(e.FRAMEBUFFER,null)}},{key:"drawElements",value:function(e){var t=this._gl,n=t.UNSIGNED_SHORT;t.drawElements(t.TRIANGLES,e,n,0)}},{key:"drawArray",value:function(e){var t=this._gl,n=t.TRIANGLES;t.drawArrays(n,0,e)}},{key:"viewport",value:function(e,t,n,a){this._gl.viewport(e,t,n,a)}},{key:"setClearColor",value:function(e,t,n,a){this._gl.clearColor(e,t,n,a)}},{key:"clear",value:function(e){this._gl.clear(e)}},{key:"clearBufferfv",value:function(e){this._gl.clearBufferfv(e,0,[.3,.3,.3,1])}},{key:"enableDepthTest",value:function(e){var t=this._gl;t.enable(e),e&&t.depthFunc(t.LEQUAL)}},{key:"deleteVao",value:function(e){r.deleteVao(this._gl,e)}}]),e}(),s=n(34),c=function(){function e(){arguments.length>0&&void 0!==arguments[0]&&arguments[0],arguments.length>1&&void 0!==arguments[1]&&arguments[1];Object(a.a)(this,e),this.data=s.a.create()}return Object(o.a)(e,[{key:"rotationByAxis",value:function(e,t){s.a.rotate(this.data,this.data,e,t.data)}}]),e}(),u=function e(t){var n=t.program,o=t.vao,r=t.geometry,i=t.textures,s=void 0===i?{}:i,u=t.renderTarget,l=t.modelMatrix,d=void 0===l?new c:l;Object(a.a)(this,e),this.program=n,this.vao=o,this.geometry=r,this.renderTarget=u,this.textures=s,this.modelMatrix=d},l=n(38),d=function e(t){var n=t.textureGL,o=t.images,r=void 0===o?[]:o;Object(a.a)(this,e),this.textureGL=n,this.images=r},f=function e(t){var n=t.target,o=t.texture;Object(a.a)(this,e),this.target=n,this.texture=o},h=function(){function e(){Object(a.a)(this,e),this.children=[]}return Object(o.a)(e,[{key:"add",value:function(e){this.children.push(e)}}]),e}(),v=function e(t,n){Object(a.a)(this,e),this.geometry=t,this.material=n},m=function e(){Object(a.a)(this,e)};m.DEG2RAD=Math.PI/180,m.RAD2DEG=180/Math.PI,m.generateUUID=function(){for(var e=[],t=0;t<256;t++)e[t]=(t<16?"0":"")+t.toString(16);return function(){var t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,a=4294967295*Math.random()|0,o=4294967295*Math.random()|0;return(e[255&t]+e[t>>8&255]+e[t>>16&255]+e[t>>24&255]+"-"+e[255&n]+e[n>>8&255]+"-"+e[n>>16&15|64]+e[n>>24&255]+"-"+e[63&a|128]+e[a>>8&255]+"-"+e[a>>16&255]+e[a>>24&255]+e[255&o]+e[o>>8&255]+e[o>>16&255]+e[o>>24&255]).toUpperCase()}}(),m.clamp=function(e,t,n){return Math.max(t,Math.min(n,e))},m.euclideanModulo=function(e,t){return(e%t+t)%t},m.mapLinear=function(e,t,n,a,o){return a+(e-t)*(o-a)/(n-t)},m.lerp=function(e,t,n){return(1-n)*e+n*t},m.smoothstep=function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*(3-2*e)},m.smootherstep=function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*e*(e*(6*e-15)+10)},m.randInt=function(e,t){return e+Math.floor(Math.random()*(t-e+1))},m.randFloat=function(e,t){return e+Math.random()*(t-e)},m.randFloatSpread=function(e){return e*(.5-Math.random())},m.degToRad=function(e){return e*m.DEG2RAD},m.radToDeg=function(e){return e*m.RAD2DEG},m.isPowerOfTwo=function(e){return 0===(e&e-1)&&0!==e},m.ceilPowerOfTwo=function(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))},m.floorPowerOfTwo=function(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))};var p=function(){function e(){Object(a.a)(this,e),this.UUID=m.generateUUID(),this.needsUpdate=!0,this.attributes={},this.attributesCode=7,this.indices=null}return Object(o.a)(e,[{key:"addAttribute",value:function(e,t){this.attributes[e]=t,this.needsUpdate=!0}},{key:"setIndex",value:function(e){this.indices=e,this.needsUpdate=!0}}]),e}(),g=n(7),b=n(6),x=n(8),y=function(){function e(t){var n=t.name,o=t.data,r=t.componentNum;Object(a.a)(this,e),this.name=n,this.data=o,this.componentNum=r,this.needsUpdate=!0}return Object(o.a)(e,[{key:"update",value:function(){this.needsUpdate=!1}}]),e}(),T=function(e){function t(){var e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:2,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2;return Object(a.a)(this,t),(e=Object(g.a)(this,Object(b.a)(t).call(this))).length=n,e.width=o,e.height=r,e.init(n,o,r),e}return Object(x.a)(t,e),Object(o.a)(t,[{key:"init",value:function(e,t,n){this.resetSize(e,t,n);this.addAttribute("uv",new y({name:"uv",data:new Float32Array([0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1]),componentNum:2})),this.addAttribute("normal",new y({name:"normal",data:new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0]),componentNum:3})),this.setIndex(new y({name:"indices",data:new Int16Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]),componentNum:1}))}},{key:"resetSize",value:function(e,t,n){var a=e/2||this.length/2,o=t/2||this.width/2,r=n/2||this.height/2,i=[-o,-r,a],s=[o,-r,a],c=[o,r,a],u=[-o,r,a],l=[-o,-r,-a],d=[o,-r,-a],f=[o,r,-a],h=[-o,r,-a],v=[].concat(i,s,c,u,l,h,f,d,u,c,f,h,i,l,d,s,s,d,f,c,i,u,h,l);this.addAttribute("position",new y({name:"position",data:new Float32Array(v),componentNum:3}))}}]),t}(p),F=function(e){function t(){var e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:2,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Object(a.a)(this,t),(e=Object(g.a)(this,Object(b.a)(t).call(this))).width=n,e.height=o,e.init(n,o),e}return Object(x.a)(t,e),Object(o.a)(t,[{key:"init",value:function(e,t){this.resetSize(e,t);this.addAttribute("uv",new y({name:"uv",data:new Float32Array([0,0,1,0,1,1,0,1]),componentNum:2})),this.addAttribute("normal",new y({name:"normal",data:new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1]),componentNum:3})),this.setIndex(new y({name:"indices",data:new Int16Array([0,1,2,0,2,3]),componentNum:1}))}},{key:"resetSize",value:function(e,t){var n=e/2||this.width/2,a=t/2||this.height/2,o=[-n,-a,0,n,-a,0,n,a,0,-n,a,0];this.addAttribute("position",new y({name:"position",data:new Float32Array(o),componentNum:3}))}}]),t}(p),w=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;Object(a.a)(this,e),this.data=s.c.set(s.c.create(),t,n,o)}return Object(o.a)(e,[{key:"set",value:function(e,t,n){s.c.set(this.data,e,t,n)}},{key:"add",value:function(e){s.c.add(this.data,this.data,e.data)}},{key:"sub",value:function(e){s.c.sub(this.data,this.data,e.data)}},{key:"distanceTo",value:function(e){var t=s.c.sub(s.c.create(),this.data,e.data);return s.c.length(t)}},{key:"normalize",value:function(){return s.c.normalize(this.data,this.data),this}},{key:"x",get:function(){return this.data[0]}},{key:"y",get:function(){return this.data[1]}},{key:"z",get:function(){return this.data[2]}}]),e}(),N=function(e){function t(){var e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:32;return Object(a.a)(this,t),(e=Object(g.a)(this,Object(b.a)(t).call(this))).radius=10,e.init(n,o,r),e}return Object(x.a)(t,e),Object(o.a)(t,[{key:"init",value:function(e,t,n){var a=[],o=[],r=[],i=[],s=0,c=-Math.PI/2,u=2*Math.PI/t,l=2*Math.PI/n,d=(t-1)*n+2;a.push(0,0,-e),r.push(0,0,-1),i.push(.5,0);for(var f=0;f<t;f++){for(var h=0;h<n;h++){var v=h+1+(f-1)*n,m=(h+1)%n+v-h,p=m+n,g=v+n;if(0===f?o.push(0,h+2,h+1):f===t-1?o.push(v,m,d-1):(o.push(v,m,p),o.push(v,p,g)),0!==f){var b=e*Math.cos(c)*Math.sin(s),x=e*Math.cos(c)*Math.cos(s),T=e*Math.sin(c),F=new w(b,x,T).normalize();a.push(b,x,T),r.push(F.x,F.y,F.z),i.push(h/n,f/t)}s+=l}c+=u}a.push(0,0,e),r.push(0,0,1),i.push(.5,1),this.addAttribute("position",new y({name:"position",data:new Float32Array(a),componentNum:3})),this.addAttribute("uv",new y({name:"uv",data:new Float32Array(i),componentNum:2})),this.addAttribute("normal",new y({name:"normal",data:new Float32Array(r),componentNum:3})),this.setIndex(new y({name:"indices",data:new Int16Array(o),componentNum:1}))}}]),t}(p),k=function e(){Object(a.a)(this,e),this.isBlend=!1,this.opacity=1},E=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Object(a.a)(this,e),this.data=s.b.set(s.b.create(),t,n)}return Object(o.a)(e,[{key:"set",value:function(e,t){s.b.set(this.data,e,t)}},{key:"add",value:function(e){s.b.add(this.data,this.data,e.data)}},{key:"sub",value:function(e){s.b.sub(this.data,this.data,e.data)}},{key:"distanceTo",value:function(e){var t=s.b.sub(s.b.create(),this.data,e.data);return s.b.length(t)}},{key:"x",get:function(){return this.data[0]}},{key:"y",get:function(){return this.data[1]}}]),e}(),C="#define GLSLIFY 1\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec2 aTexCoords;\nlayout (location = 2) in vec3 aNormal;\n\nout vec2 TexCoords;\nout vec3 WorldPos;\nout vec3 Normal;\n\nuniform mat4 projection;\nuniform mat4 view;\nuniform mat4 model;\n\nvoid main()\n{\n    TexCoords = aTexCoords;\n    WorldPos = vec3(model * vec4(aPos, 1.0));\n    Normal = mat3(model) * aNormal;\n\n    gl_Position =  projection * view * vec4(WorldPos, 1.0);\n}\n",A="#define GLSLIFY 1\nlayout (location = 0) in vec3 aPos;\n\nout vec3 WorldPos;\n\nuniform mat4 projection;\nuniform mat4 view;\n\nvoid main()\n{\n    WorldPos = aPos;\n    gl_Position =  projection * view * vec4(WorldPos, 1.0);\n}\n",P=function(){function e(){Object(a.a)(this,e),this.version="#version 300 es\n",this.precision="",this.main="",this.define="",this.defineMap={}}return Object(o.a)(e,[{key:"setVersion",value:function(e){this.version="#version "+e+" es\n"}},{key:"setPrecision",value:function(e){return this.precision="precision "+e+" float;\n",this}},{key:"addDefine",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=this.defineMap;if(n[e]===t)return this;for(var a in this.define="",n[e]=t,n)this.define+="#define "+a+" "+n[a]+"\n";return this}},{key:"addMain",value:function(e){return e=e.replace("#define GLSLIFY 1",""),this.main="\n"+e,this}},{key:"getSource",value:function(){return this.version+this.precision+this.define+this.main}}]),e}(),L={test:{vs:(new P).addMain("#define GLSLIFY 1\nlayout (location = 0) in vec3 aPos;\n\nout vec3 worldPos;\n\nuniform mat4 projection;\nuniform mat4 view;\n\nvoid main()\n{\n    worldPos = aPos;\n    gl_Position =  projection * view * vec4(aPos, 1.0);\n}\n"),fs:(new P).addMain("#define GLSLIFY 1\nin vec3 worldPos;\n\nuniform sampler2D equirectangularMap;\n\nout vec4 FragColor;\n\nvoid main()\n{\n    FragColor = vec4(worldPos,1.0);\n}\n").setPrecision("mediump")},book:{vs:(new P).addMain(C),fs:(new P).addMain('#define GLSLIFY 1\nout vec4 FragColor;\nin vec2 TexCoords;\nin vec3 WorldPos;\nin vec3 Normal;\n\nuniform vec2 mouse;\nuniform float width;\nuniform float height;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\n\nconst float pi = 3.14159;\nconst float twopi = 6.28319;\n\nconst float e0 = 0.018;\nconst float ppow = 2.0;\n\nconst float bcolorMix = 0.67;\nconst float maxBcolVal = 0.4;\n\nconst float diffint = 1.2;\nconst float ambientt = 0.1;\nconst float ambientb = 0.4;\n\nconst vec2 specpos = vec2(0.85, -0.2);\nconst float specpow = 5.;\nconst float specwidth = 0.4;\nconst float specint = 0.6;\n\nconst vec2 shadowoffset = vec2(0.07, -0.04);\nconst float shadowsmoothness = 0.012;\nconst float shadowint = 0.25;\n\nconst float aawidth = 0.01;\nconst int aasamples = 3;\n\nconst bool showpoints = false;\nconst bool colors = false;\nconst bool anim = false;\n\n//#define swap_x\n\n// Simple "random" function\nfloat random(float co)\n{\n    return fract(sin(co*12.989) * 43758.545);\n}\n\nvec4 getPagebackColor()\n{\n\n    float cn;\n    if (mouse.x==0. && mouse.y==0. && anim)\n        cn = floor(iTime/3.5);\n    else\n        cn = 1.0;\n    vec4 pagebackColor;\n    pagebackColor.r = maxBcolVal*random(cn + 263.714);\n    pagebackColor.g = maxBcolVal*random(cn*4. - 151.894);\n    pagebackColor.b = maxBcolVal*random(cn*7. + 87.548);\n    pagebackColor.a = 1.0;\n    return pagebackColor;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    float xr = vect.x*cos(angle) + vect.y*sin(angle);\n    float yr = vect.x*sin(angle) - vect.y*cos(angle);\n    return vec2(xr, yr);\n}\n\n// Curl function on the axis bottom left corner - corner of the sheet\nfloat pageFunction(float x, float e)\n{\n    return pow(pow(x, ppow) - e, 1./ppow);\n}\n\n// Derivate of the curl function for light calculations\nfloat pageFunctionDer(float x, float e)\n{\n    return pow(x, ppow - 1.)/pow(pow(x, ppow) - e, (ppow - 1.)/ppow);\n}\n\nvec4 turnPage(vec2 fragCoord,vec2 uv)\n{\n\t// General calculations\n    float ratio = width/height;\n\n    // As long as one doesn\'t click on the canvas, the animation runs\n\n    vec2 mouse2 = mouse;\n    #ifdef swap_x\n    mouse2.x = width - mouse.x;\n    #endif\n\n    mouse2.x = max(min(mouse2.x,ratio),0.001);\n    mouse2.y = max(min(sqrt(pow(ratio/2.,2.) - pow(mouse2.x - ratio/2.,2.)),mouse2.y),0.0002);\n\n    vec2 mpoint = mouse2;\n\n    vec2 midmpoint = mpoint*0.5;\n    vec2 midmpointUV = midmpoint/vec2(height,height);\n\n    float mdist = distance(fragCoord, mpoint);\n    float angle = atan(mpoint.y/mpoint.x);\n\n    vec2 uvr = rotateVec(uv -  midmpointUV, angle);\n    float midBottomX = length(midmpointUV)/cos(-angle);\n\n    float curl = pow(ratio/2. - midBottomX, 1.);\n    //curl *=pow(length(mpoint),4.);\n\n    float e = curl * (e0*pow(mdist/height, 2.) + 0.02*e0*smoothstep(0., 0.12, mdist/height));\n    float pagefunc = pageFunction(uvr.x, e);\n    vec2 uvr2 = vec2(pagefunc, uvr.y);\n    vec2 uvr3 = rotateVec(uvr2, -angle) - vec2(1., -1.)*midmpointUV;\n\n    vec2 uvr2b = vec2(-pagefunc, uvr.y);\n    vec2 uvr3b = rotateVec(uvr2b, -angle) - vec2(1., -1.)*midmpointUV;\n\n    vec4 i;\n    // Turned page\n    if (uvr.x>0. && uvr3b.y>0.)\n    {\n        vec2 uvcorr = vec2(ratio, 1.);\n        vec2 uvrcorr = rotateVec(uvcorr - midmpointUV, angle);\n        float pagefunccorr = pageFunction(uvrcorr.x, e);\n        vec2 uvrcorr2 = vec2(-pagefunccorr, uvrcorr.y);\n        vec2 uvrcorr3 = rotateVec(uvrcorr2, -angle) - vec2(1., -1.)*midmpointUV;\n\n        float pagefuncder = pageFunctionDer(uvr.x, e);\n        float intfac = 1. - diffint*(1. - 1./pagefuncder);\n\n        if(uvr3.x>=0. || uvr3.y<=0.)\n        {\n            // Top of the turned page\n        \tfloat mdists = distance(fragCoord, mpoint)*0.7 - 55.;\n        \tfloat es = e0*pow(mdists/height, 2.) + 0.02*e0*smoothstep(0., 0.08, mdist/height);\n        \tvec2 uvrs = rotateVec(uv -midmpointUV - shadowoffset, angle);\n        \tfloat pagefuncs = pageFunction(uvrs.x + 0.015, es - 0.001);\n        \tvec2 uvr2s = vec2(pagefuncs, uvrs.y);\n        \tvec2 uvr3s = rotateVec(uvr2s, -angle) - vec2(1., -1.)*midmpointUV;\n        \tfloat shadow = 1. - (1. - smoothstep(-shadowsmoothness, shadowsmoothness, uvr3s.x))*(1. - smoothstep(shadowsmoothness, -shadowsmoothness, uvr3s.y));\n\n            float difft = intfac*(1. - ambientt) + ambientt;\n        \tdifft = difft*(shadow*shadowint + 1. - shadowint)/2. + mix(1. - shadowint, difft, shadow)/2.;\n            i = texture(iChannel0, mod((uvr3b - uvrcorr3)/vec2(ratio, 1.), 1.));\n        }\n        else\n        {\n            // Bottom of the turned page\n            float diffb = intfac*(1. - ambientb) + ambientb;\n        \tfloat spec = pow(smoothstep(specpos.x - 0.35, specpos.x, intfac)*smoothstep(specpos.x + 0.35, specpos.x, intfac), specpow);\n        \tspec*= min(curl*10.,1.)*specint*pow(1. - pow(clamp(abs(uvr.y - specpos.y), 0., specwidth*2.), 2.)/specwidth, specpow);\n\n        \tvec4 bottomUV = texture(iChannel1, mod((uvr3 - uvrcorr3)/vec2(ratio, 1.),1.));\n            i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):mix(bottomUV, getPagebackColor(), bcolorMix));\n            i = mix(i, vec4(1.0), spec);\n        }\n    }\n    else\n    {\n        // "Background" with simple shadow\n\n        vec2 mpointbg = vec2(0.2, 0.01);\n        vec2 midmpointbg = mpointbg*0.5;\n        float mdistbg = distance(fragCoord, mpointbg);\n        float ebg = e0*pow(mdistbg/height, 2.) + 0.01*e0*smoothstep(0., 0.12, mdistbg/height);\n        float anglebg = 0.001; //- atan(mpointbg.x/mpointbg.y) + pi*0.5;\n        vec2 uvrbg = rotateVec(uv - midmpointbg/height, anglebg);\n        //float pagefuncbg = mix(uvrbg.x, pageFunction(uvrbg.x, ebg), clamp(uvrbg.x*5., 0., 1.));\n        float pagefuncbg;\n        if (uvrbg.x<0.15)\n           pagefuncbg = uvrbg.x;\n        else\n           pagefuncbg = mix(uvrbg.x, pageFunction(uvrbg.x, ebg), smoothstep(mpoint.x/width + 0.1, mpoint.x/width, uvrbg.x));\n\n        vec2 uvr2bbg = vec2(-pagefuncbg, uvrbg.y);\n        vec2 uvr3bbg = rotateVec(uvr2bbg, -anglebg) - vec2(1., -1.)*midmpointbg/vec2(height,height);\n        vec2 uvcorrbg = vec2(ratio, 1.);\n        vec2 uvrcorrbg = rotateVec(uvcorrbg - midmpointbg/vec2(height,height), anglebg);\n        float pagefunccorrbg = pageFunction(uvrcorrbg.x, ebg);\n        vec2 uvrcorr2bg = vec2(-pagefunccorrbg, uvrcorrbg.y);\n        vec2 uvrcorr3bg = rotateVec(uvrcorr2bg, -anglebg) - vec2(1., -1.)*midmpointbg/vec2(height,height);\n        float pagefuncderbg = pageFunctionDer(uvrbg.x, ebg);\n        float intfacbg = 1. - diffint*(1. - 1./pagefuncderbg);\n        float difftbg = intfacbg*(1. - ambientt) + ambientt;\n        i = colors?difftbg*vec4(0.3, 0.3, 1., 1.):texture(iChannel1, mod((uvr3bbg - uvrcorr3bg)/vec2(-ratio, 1.), 1.));\n        float bgshadow = 1. + shadowint*smoothstep(-0.08+shadowsmoothness*4., -0.08, uvr3b.y) - shadowint;\n\n        if (uvr3b.y<0.)\n           i*= bgshadow;\n    }\n    return i;\n}\n\nvoid main()\n{\n\n\tfloat ratio =width/height;\n\tvec2 fragCoord = TexCoords*vec2(width,height);\n\tvec2 uv = vec2(TexCoords.x*ratio,TexCoords.y);\n\n    #ifdef swap_x\n    uv.x = ratio - uv.x;\n    fragCoord.x = width - fragCoord.x;\n    #endif\n\n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= turnPage(fragCoord + vec2(ox, oy),uv);\n       }\n    }\n    vec4 ocol = vs/vec4(aasamples*aasamples);\n    FragColor = ocol;\n}\n').setPrecision("mediump")},pbr:{vs:(new P).addMain(C),fs:(new P).addMain("#define GLSLIFY 1\nout vec4 FragColor;\nin vec2 TexCoords;\nin vec3 WorldPos;\nin vec3 Normal;\n\n// material parameters\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D metallicMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D aoMap;\nuniform float opacity;\n\n// IBL\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D brdfLUT;\n\n// lights\nuniform vec3 pointLightPositions[POINT_LIGHT_NUMBER];\nuniform vec3 pointLightColors[POINT_LIGHT_NUMBER];\n\nuniform vec3 camPos;\n\nconst float PI = 3.14159265359;\n\nvec3 getNormalFromMap()\n{\n    vec3 tangentNormal = texture(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(Normal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// ----------------------------------------------------------------------------\nvoid main()\n{\n    vec3 albedo = pow(texture(albedoMap, TexCoords).rgb,vec3(2.2));\n    float metallic = texture(metallicMap, TexCoords).r;\n    float roughness = texture(roughnessMap, TexCoords).r;\n    float ao = texture(aoMap, TexCoords).r;\n\n    #ifdef NORMAL_MAP\n    vec3 N = getNormalFromMap();\n    #else\n    vec3 N = Normal;\n    #endif\n\n    vec3 V = normalize(camPos - WorldPos);\n    vec3 R = reflect(-V, N);\n\n    // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0\n    // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        // calculate per-light radiance\n        vec3 L = normalize(pointLightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n        float distance = length(pointLightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance = pointLightColors[i] * attenuation * opacity;\n\n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);\n\n        vec3 nominator    = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; // 0.001 to prevent divide by zero.\n        vec3 specular = nominator / denominator;\n\n         // kS is equal to Fresnel\n        vec3 kS = F;\n        // for energy conservation, the diffuse and specular light can't\n        // be above 1.0 (unless the surface emits light); to preserve this\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\n        vec3 kD = vec3(1.0) - kS;\n        // multiply kD by the inverse metalness such that only non-metals\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\n        // have no diffuse light).\n        kD *= 1.0 - metallic;\n\n        // scale light by NdotL\n        float NdotL = max(dot(N, L), 0.0);\n        float VdotL = pow(max(dot(-V, L), 0.0),3.);\n\n        // add to outgoing radiance Lo\n        Lo += (kD * albedo / PI + specular) * radiance * NdotL+(1.0-opacity)*radiance*VdotL; // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\n    }\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = texture(irradianceMap, N).rgb;\n    vec3 diffuse      = irradiance * albedo;\n\n    // sample both the pre-filter map and the BRDF lut and combine them together as per the Split-Sum approximation to get the IBL specular part.\n    const float MAX_REFLECTION_LOD = 4.0;\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\n    vec2 brdf  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n\n    vec3 color =  ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2));\n\n    FragColor = vec4(color,opacity);\n}\n").setPrecision("mediump").addDefine("POINT_LIGHT_NUMBER",4)},background:{vs:(new P).addMain("#define GLSLIFY 1\nlayout (location = 0) in vec3 aPos;\n\nuniform mat4 projection;\nuniform mat4 view;\n\nout vec3 WorldPos;\n\nvoid main()\n{\n    WorldPos = aPos;\n\n\tmat4 rotView = mat4(mat3(view));\n\tvec4 clipPos = projection * rotView * vec4(WorldPos, 1.0);\n\n\tgl_Position = clipPos.xyww;\n}\n"),fs:(new P).addMain("#define GLSLIFY 1\nout vec4 FragColor;\nin vec3 WorldPos;\n\nuniform samplerCube environmentMap;\n\nvoid main()\n{\n    vec3 envColor = textureLod(environmentMap, WorldPos, 0.0).rgb;\n\n    // HDR tonemap and gamma correct\n    envColor = envColor / (envColor + vec3(1.0));\n    envColor = pow(envColor, vec3(1.0/2.2));\n\n    FragColor = vec4(envColor, 1.0);\n}\n").setPrecision("mediump")},brdf:{vs:(new P).addMain("#define GLSLIFY 1\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec2 aTexCoords;\n\nout vec2 TexCoords;\n\nvoid main()\n{\n    TexCoords = aTexCoords;\n\tgl_Position = vec4(aPos, 1.0);\n}\n"),fs:(new P).addMain("#define GLSLIFY 1\nout vec2 FragColor;\nin vec2 TexCoords;\n\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// efficient VanDerCorpus calculation.\nfloat RadicalInverse_VdC(uint bits)\n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n\treturn vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n// ----------------------------------------------------------------------------\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n\tfloat a = roughness*roughness;\n\n\tfloat phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n\t// from spherical coordinates to cartesian coordinates - halfway vector\n\tvec3 H;\n\tH.x = cos(phi) * sinTheta;\n\tH.y = sin(phi) * sinTheta;\n\tH.z = cosTheta;\n\n\t// from tangent-space H vector to world-space sample vector\n\tvec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent   = normalize(cross(up, N));\n\tvec3 bitangent = cross(N, tangent);\n\n\tvec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\treturn normalize(sampleVec);\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    // note that we use a different k for IBL\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    const uint SAMPLE_COUNT = 1024u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        // generates a sample vector that's biased towards the\n        // preferred alignment direction (importance sampling).\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n// ----------------------------------------------------------------------------\nvoid main()\n{\n    vec2 integratedBRDF = IntegrateBRDF(TexCoords.x, TexCoords.y);\n    FragColor = integratedBRDF;\n}\n").setPrecision("mediump")},convert_2d_to_cubemap:{vs:(new P).addMain(A),fs:(new P).addMain("#define GLSLIFY 1\nout vec4 FragColor;\nin vec3 WorldPos;\n\nuniform sampler2D equirectangularMap;\n\nconst vec2 invAtan = vec2(0.1591, 0.3183);\nvec2 SampleSphericalMap(vec3 v)\n{\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n    uv *= invAtan;\n    uv += 0.5;\n    return uv;\n}\n\nvoid main()\n{\n    vec2 uv = SampleSphericalMap(normalize(WorldPos));\n    vec3 color = texture(equirectangularMap, uv).rgb;\n\n    FragColor = vec4(color, 1.0);\n}\n").setPrecision("mediump")},irradiance_convolution:{vs:(new P).addMain(A),fs:(new P).addMain("#define GLSLIFY 1\nout vec4 FragColor;\nin vec3 WorldPos;\n\nuniform samplerCube environmentMap;\n\nconst float PI = 3.14159265359;\n\nvoid main()\n{\n    vec3 N = normalize(WorldPos);\n\n    vec3 irradiance = vec3(0.0);\n\n    // tangent space calculation from origin point\n    vec3 up    = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, N);\n    up            = cross(N, right);\n\n    float sampleDelta = 0.025;\n    float nrSamples = 0.0f;\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\n    {\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\n        {\n            // spherical to cartesian (in tangent space)\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n            // tangent space to world\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N;\n\n            irradiance += texture(environmentMap, sampleVec).rgb * cos(theta) * sin(theta);\n            nrSamples++;\n        }\n    }\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\n\n    FragColor = vec4(irradiance, 1.0);\n}\n").setPrecision("mediump")},prefilter:{vs:(new P).addMain(A),fs:(new P).addMain("#define GLSLIFY 1\nout vec4 FragColor;\nin vec3 WorldPos;\n\nuniform samplerCube environmentMap;\nuniform float roughness;\n\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// efficient VanDerCorpus calculation.\nfloat RadicalInverse_VdC(uint bits)\n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n\treturn vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n// ----------------------------------------------------------------------------\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n\tfloat a = roughness*roughness;\n\n\tfloat phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n\t// from spherical coordinates to cartesian coordinates - halfway vector\n\tvec3 H;\n\tH.x = cos(phi) * sinTheta;\n\tH.y = sin(phi) * sinTheta;\n\tH.z = cosTheta;\n\n\t// from tangent-space H vector to world-space sample vector\n\tvec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent   = normalize(cross(up, N));\n\tvec3 bitangent = cross(N, tangent);\n\n\tvec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\treturn normalize(sampleVec);\n}\n// ----------------------------------------------------------------------------\nvoid main()\n{\n    vec3 N = normalize(WorldPos);\n\n    // make the simplyfying assumption that V equals R equals the normal\n    vec3 R = N;\n    vec3 V = R;\n\n    const uint SAMPLE_COUNT = 1024u;\n    vec3 prefilteredColor = vec3(0.0);\n    float totalWeight = 0.0;\n\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        // generates a sample vector that's biased towards the preferred alignment direction (importance sampling).\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(dot(N, L), 0.0);\n        if(NdotL > 0.0)\n        {\n            // sample from the environment's mip level based on roughness/pdf\n            float D   = DistributionGGX(N, H, roughness);\n            float NdotH = max(dot(N, H), 0.0);\n            float HdotV = max(dot(H, V), 0.0);\n            float pdf = D * NdotH / (4.0 * HdotV) + 0.0001;\n\n            float resolution = 512.0; // resolution of source cubemap (per face)\n            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);\n            float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n\n            float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel);\n\n            prefilteredColor += textureLod(environmentMap, L, mipLevel).rgb * NdotL;\n            totalWeight      += NdotL;\n        }\n    }\n\n    prefilteredColor = prefilteredColor / totalWeight;\n\n    FragColor = vec4(prefilteredColor, 1.0);\n}\n").setPrecision("mediump")}},R=n(35),_=n(32),M=n.n(_),V=n(33),I=function e(){Object(a.a)(this,e),this.vertices=[],this.normals=[],this.colors=[],this.uvs=[]},S=function(){function e(){Object(a.a)(this,e),this.index=0,this.name="",this.mtllib="",this.smooth=!1,this.groupStart=0,this.groupEnd=-1,this.groupCount=-1,this.inherited=!1}return Object(o.a)(e,[{key:"clone",value:function(t){var n=new e(this.name,this.mtllib);return n.index="number"===typeof t?t:this.index,n.smooth=this.smooth,n.groupStart=this.groupStart,n.groupEnd=this.groupEnd,n.groupCount=this.groupCount,n.inherited=this.inherited,n}},{key:"setIndex",value:function(e){this.index=e}},{key:"setSmooth",value:function(e){this.smooth=e}},{key:"setName",value:function(e){this.name=e}},{key:"setMtlLib",value:function(e){this.mtllib=e}}]),e}(),U=function(){function e(){Object(a.a)(this,e),this.name="",this.geometry=new I,this.materials=[],this.smooth=!0}return Object(o.a)(e,[{key:"startMaterial",value:function(e,t){var n=this._finalize(!1);n&&(n.inherited||n.groupCount<=0)&&this.materials.splice(n.index,1);var a=new S;return a.setIndex(this.materials.length),a.setName(e||""),a.setMtlLib(Array.isArray(t)&&t.length>0?t[t.length-1]:""),a.setSmooth(void 0!==n?n.smooth:this.smooth),a.groupStart=void 0!==n?n.groupEnd:0,this.materials.push(a),a}},{key:"currentMaterial",value:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]}},{key:"_finalize",value:function(e){var t=this.currentMaterial();if(t&&-1===t.groupEnd&&(t.groupEnd=this.geometry.vertices.length/3,t.groupCount=t.groupEnd-t.groupStart,t.inherited=!1),e&&this.materials.length>1)for(var n=this.materials.length-1;n>=0;n--)this.materials[n].groupCount<=0&&this.materials.splice(n,1);if(e&&0===this.materials.length){var a=new S;a.setSmooth(this.smooth),this.materials.push(a)}return t}},{key:"setName",value:function(e){this.name=e||""}}]),e}(),j=function(){function e(){Object(a.a)(this,e),this.objects=[],this.object=[],this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.materialLibraries=[]}return Object(o.a)(e,[{key:"startObject",value:function(e,t){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=!1!==t);var n=this.object&&"function"===typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"===typeof this.object._finalize&&this.object._finalize(!0),this.object=new U,this.object.setName(e),n&&n.name&&"function"===typeof n.clone){var a=n.clone(0);a.inherited=!0,this.object.materials.push(a)}this.objects.push(this.object)}},{key:"finalize",value:function(){this.object&&"function"===typeof this.object._finalize&&this.object._finalize(!0)}},{key:"parseVertexIndex",value:function(e,t){var n=parseInt(e,10);return 3*(n>=0?n-1:n+t/3)}},{key:"parseNormalIndex",value:function(e,t){var n=parseInt(e,10);return 3*(n>=0?n-1:n+t/3)}},{key:"parseUVIndex",value:function(e,t){var n=parseInt(e,10);return 2*(n>=0?n-1:n+t/2)}},{key:"addVertex",value:function(e,t,n){var a=this.vertices,o=this.object.geometry.vertices;o.push(a[e+0],a[e+1],a[e+2]),o.push(a[t+0],a[t+1],a[t+2]),o.push(a[n+0],a[n+1],a[n+2])}},{key:"addVertexPoint",value:function(e){var t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])}},{key:"addVertexLine",value:function(e){var t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])}},{key:"addNormal",value:function(e,t,n){var a=this.normals,o=this.object.geometry.normals;o.push(a[e+0],a[e+1],a[e+2]),o.push(a[t+0],a[t+1],a[t+2]),o.push(a[n+0],a[n+1],a[n+2])}},{key:"addColor",value:function(e,t,n){var a=this.colors,o=this.object.geometry.colors;o.push(a[e+0],a[e+1],a[e+2]),o.push(a[t+0],a[t+1],a[t+2]),o.push(a[n+0],a[n+1],a[n+2])}},{key:"addUV",value:function(e,t,n){var a=this.uvs,o=this.object.geometry.uvs;o.push(a[e+0],a[e+1]),o.push(a[t+0],a[t+1]),o.push(a[n+0],a[n+1])}},{key:"addUVLine",value:function(e){var t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])}},{key:"addFace",value:function(e,t,n,a,o,r,i,s,c){var u=this.vertices.length,l=this.parseVertexIndex(e,u),d=this.parseVertexIndex(t,u),f=this.parseVertexIndex(n,u);if(this.addVertex(l,d,f),void 0!==a&&""!==a){var h=this.uvs.length;l=this.parseUVIndex(a,h),d=this.parseUVIndex(o,h),f=this.parseUVIndex(r,h),this.addUV(l,d,f)}if(void 0!==i&&""!==i){var v=this.normals.length;l=this.parseNormalIndex(i,v),d=i===s?l:this.parseNormalIndex(s,v),f=i===c?l:this.parseNormalIndex(c,v),this.addNormal(l,d,f)}this.colors.length>0&&this.addColor(l,d,f)}},{key:"addPointGeometry",value:function(e){this.object.geometry.type="Points";for(var t=this.vertices.length,n=0,a=e.length;n<a;n++)this.addVertexPoint(this.parseVertexIndex(e[n],t))}},{key:"addLineGeometry",value:function(e,t){this.object.geometry.type="Line";for(var n=this.vertices.length,a=this.uvs.length,o=0,r=e.length;o<r;o++)this.addVertexLine(this.parseVertexIndex(e[o],n));for(var i=0,s=t.length;i<s;i++)this.addUVLine(this.parseUVIndex(t[i],a))}}]),e}(),O=/^[og]\s*(.+)?/,D=/^mtllib /,G=/^usemtl /,B=function(){function e(){Object(a.a)(this,e)}return Object(o.a)(e,[{key:"load",value:function(){var e=Object(V.a)(M.a.mark(function e(t){var n,a;return M.a.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return n=new R.a,e.next=3,n.load(t,void 0,R.a.TEXT);case 3:return a=e.sent,e.abrupt("return",this.parse(a));case 5:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"setMaterials",value:function(e){return this.materials=e,this}},{key:"parse",value:function(e){console.time("OBJLoader");var t=new j;t.startObject("",!1),-1!==e.indexOf("\r\n")&&(e=e.replace(/\r\n/g,"\n")),-1!==e.indexOf("\\\n")&&(e=e.replace(/\\\n/g,""));for(var n=e.split("\n"),a="",o="",r=[],i="function"===typeof"".trimLeft,s=0,c=n.length;s<c;s++)if(a=n[s],0!==(a=i?a.trimLeft():a.trim()).length&&"#"!==(o=a.charAt(0)))if("v"===o){var u=a.split(/\s+/);switch(u[0]){case"v":t.vertices.push(parseFloat(u[1]),parseFloat(u[2]),parseFloat(u[3])),8===u.length&&t.colors.push(parseFloat(u[4]),parseFloat(u[5]),parseFloat(u[6]));break;case"vn":t.normals.push(parseFloat(u[1]),parseFloat(u[2]),parseFloat(u[3]));break;case"vt":t.uvs.push(parseFloat(u[1]),parseFloat(u[2]))}}else if("f"===o){for(var l=a.substr(1).trim().split(/\s+/),d=[],f=0,h=l.length;f<h;f++){var v=l[f];if(v.length>0){var m=v.split("/");d.push(m)}}for(var p=d[0],g=1,b=d.length-1;g<b;g++){var x=d[g],y=d[g+1];t.addFace(p[0],x[0],y[0],p[1],x[1],y[1],p[2],x[2],y[2])}}else if("l"===o){var T=a.substring(1).trim().split(" "),F=[],w=[];if(-1===a.indexOf("/"))F=T;else for(var N=0,k=T.length;N<k;N++){var E=T[N].split("/");""!==E[0]&&F.push(E[0]),""!==E[1]&&w.push(E[1])}t.addLineGeometry(F,w)}else if("p"===o){var C=a.substr(1).trim().split(" ");t.addPointGeometry(C)}else if(null!==(r=O.exec(a))){var A=(" "+r[0].substr(1).trim()).substr(1);t.startObject(A)}else if(G.test(a))t.object.startMaterial(a.substring(7).trim(),t.materialLibraries);else if(D.test(a))t.materialLibraries.push(a.substring(7).trim());else{if("s"!==o){if("\0"===a)continue;throw new Error('THREE.OBJLoader: Unexpected line: "'+a+'"')}if((r=a.split(" ")).length>1){var P=r[1].trim().toLowerCase();t.object.smooth="0"!==P&&"off"!==P}else t.object.smooth=!0;var L=t.object.currentMaterial();L&&(L.smooth=t.object.smooth)}return t.finalize(),t}}]),e}(),H=function(){function e(){Object(a.a)(this,e)}return Object(o.a)(e,[{key:"parse",value:function(e,t){var n=this;return t.objects.forEach(function(t){if(!(t.geometry.vertices.length<=0)){var a=n.parseGeometry(t.geometry),o=n.parseMaterial(t.materials),r=new v(a,o);r.name=t.name,e.add(r)}}),e}},{key:"parseGeometry",value:function(e){var t=new p;return t.addAttribute("position",new y({name:"position",data:new Float32Array(e.vertices),componentNum:3}),3),t.addAttribute("uv",new y({name:"uv",data:new Float32Array(e.uvs),componentNum:2}),3),t.addAttribute("normal",new y({name:"normal",data:new Float32Array(e.normals),componentNum:3}),3),t}},{key:"parseMaterial",value:function(e){return new k}}]),e}();n.d(t,"o",function(){return i}),n.d(t,"i",function(){return L}),n.d(t,"h",function(){return f}),n.d(t,"k",function(){return l.a}),n.d(t,"l",function(){return d}),n.d(t,"c",function(){return u}),n.d(t,"n",function(){return w}),n.d(t,"m",function(){return E}),n.d(t,"e",function(){return h}),n.d(t,"a",function(){return T}),n.d(t,"g",function(){return F}),n.d(t,"j",function(){return N}),n.d(t,"b",function(){return R.a}),n.d(t,"d",function(){return B}),n.d(t,"f",function(){return H})},38:function(e,t,n){"use strict";n.d(t,"a",function(){return o});var a=n(2),o=function e(t){var n=t.textureGL,o=t.image;Object(a.a)(this,e),this.textureGL=n,this.image=o}}}]);